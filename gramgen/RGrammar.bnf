{
  classHeader="header.txt"
  parserClass="com.r4intellij.lang.parser.RParser"
  stubParserClass="com.r4intellij.lang.parser.GrammarParserUtil"

  implements="com.r4intellij.psi.RCompositeElement"
  extends="com.r4intellij.psi.impl.RCompositeElementImpl"

  psiClassPrefix="R"
  psiImplClassSuffix="Impl"
  psiPackage="com.r4intellij.psi"
  psiImplPackage="com.r4intellij.psi.impl"

  elementTypeHolderClass="com.r4intellij.psi.RTypes"
  elementTypePrefix="R_"
  elementTypeClass="com.r4intellij.psi.RCompositeElementType"
  tokenTypeClass="com.r4intellij.lang.lexer.RTokenType"



  // tokens as defined in original_r_grammar.y
// onthefly STR_CONST
// onthefly NUM_CONST
// onthefly NULL_CONST
// onthefly SYMBOL
// onthefly FUNCTION
LEFT_ASSIGN="<-"
EQ_ASSIGN="="
RIGHT_ASSIGN="->"
LBB="[["
RBB="]]"
// onthefly FOR
// onthefly IN
// onthefly IF
// onthefly ELSE
// onthefly WHILE
// onthefly NEXT
// onthefly BREAK
// onthefly REPEAT
GT=">"
GE=">="
LT="<"
LE="<="
EQ="=="
NE="!="
AND="&"
OR="|"
AND2="&&"
OR2="||"
NS_GET="::"
NS_GET_INT=":::"
// onthefly COMMENT
// onthefly SPACES
// onthefly ROXYGEN_COMMENT
SYMBOL_FORMALS="..."
// just the = with a function definition, there should be part of a parser rule EQ_FORMALS
// see example parsing ::= the name of a named argument in a function call EQ_SUB
// see example parsing ::= the = of a named argument in a function call SYMBOL_SUB
// SYMBOL_FUNCTION_CALL the name of the function of a function call
// ?? SYMBOL_PACKAGE
// ?? COLON_ASSIGN
SLOT="@"

// additional tokens because of grammar def
SEMICOLON=";"
LEFT_BRACE="{"
RIGHT_BRACE="}"
LEFT_BRACKET="["
RIGHT_BRACKET="]"
LEFT_PAREN="("
RIGHT_PAREN=")"
EOL="EOL"

COLON=":"
COMMA=","
SEMICOLON=";"
DOT="."
TILDE="~"

LIST_SUBSET="$"
//VARARGS="..."
ARITH_PLUS="+"
ARITH_MINUS="-"
NEGATION="!"
QUESTION="?"
ARITH_MULT="*"
ARITH_DIV="/"
ARITH_MOD="%"
ARITH_EXPONENTIAION="^"
//onthefly ARITH_MISC

  named="com.r4intellij.psi.RNamedElement"
  namedImpl="com.r4intellij.psi.impl.RNamedElementImpl"
}


external grammar ::= parseGrammar prog

prog ::=
//END_OF_INPUT //todo match an empty file --> add unit test
       expr_or_assign? EOL
    |  expr_or_assign? ';'
     {recoverUntil="prog_recover_until"}
private prog_recover_until::=!(prog)


expr_or_assign ::= EOL* (equal_assign | expr |  COMMENT )


equal_assign ::= expr EQ_ASSIGN expr_or_assign

expr ::=  ('{' exprlist '}' |
	'(' expr_or_assign ')' |
	'-' expr |
	'+' expr |
	'!' expr |
	'~' expr |
	'?' expr |
	fundef |
	IF ifcond expr_or_assign [ELSE expr_or_assign] |
	FOR forcond expr_or_assign |
	WHILE cond expr_or_assign |
	REPEAT expr_or_assign |
	SYMBOL NS_GET SYMBOL |
	SYMBOL NS_GET STR_CONST |
	STR_CONST NS_GET SYMBOL |
	STR_CONST NS_GET STR_CONST |
	SYMBOL NS_GET_INT SYMBOL |
	SYMBOL NS_GET_INT STR_CONST |
	STR_CONST NS_GET_INT SYMBOL |
	STR_CONST NS_GET_INT STR_CONST |
	NUM_CONST |
	string_literal |
	NULL_CONST |
	variable |
	NEXT |
	BREAK) // end of first half
    (( ':' | '+' | '-' | '*' | '/' | '^' | ARITH_MISC | '%' | '~' | '?' | LT | LE | EQ | NE | GE | GT | AND | OR | AND2 | OR2 | LEFT_ASSIGN | RIGHT_ASSIGN ) expr |
	'(' sublist? ')' |
	'[[' sublist ']]' |
	'[' ','? sublist ','? ']' |
	'$' variable |
	'$' STR_CONST |
	'@' variable |
	'@' STR_CONST
	)* ;

exprlist ::= [(expr_or_assign) (';' expr_or_assign | EOL expr_or_assign |';' |  EOL)*] EOL* ;


string_literal ::= STR_CONST //{extends="" implements=""}

variable ::= SYMBOL {extends=namedImpl implements=named};

cond ::= '(' expr ')'

ifcond ::= '(' expr ')'

forcond ::= '(' variable IN expr ')'

fundef ::= FUNCTION '(' formlist? ')'  expr_or_assign;

// todo avoid that the parser accepts several symbol formals
formlist ::= form (EOL? ',' EOL? form)*

form ::=  SYMBOL '=' expr
        | SYMBOL
        | STR_CONST '=' expr
        | STR_CONST
        | SYMBOL_FORMALS

sublist ::=  sub? (',' sub)*

sub ::= EOL*
    (SYMBOL '=' expr
//   | SYMBOL
   | STR_CONST '=' expr
//   | STR_CONST
   | NULL_CONST '=' expr
//   | NULL_CONST
   | expr ) EOL*

