{
  classHeader="header.txt"
  parserClass="com.r4intellij.lang.parser.RParser"
  stubParserClass="com.r4intellij.lang.parser.GrammarParserUtil"

  implements="com.r4intellij.psi.RCompositeElement"
  extends="com.r4intellij.psi.impl.RCompositeElementImpl"

  psiClassPrefix="R"
  psiImplClassSuffix="Impl"
  psiPackage="com.r4intellij.psi"
  psiImplPackage="com.r4intellij.psi.impl"

  elementTypeHolderClass="com.r4intellij.psi.RTypes"
  elementTypePrefix="R_"
  elementTypeClass="com.r4intellij.psi.RCompositeElementType"
  tokenTypeClass="com.r4intellij.lang.lexer.RTokenType"



  // tokens as defined in original_r_grammar.y
// onthefly STR_CONST
// onthefly NUM_CONST
// onthefly NULL_CONST
// onthefly SYMBOL
// onthefly FUNCTION
LEFT_ASSIGN="<-"
EQ_ASSIGN="="
RIGHT_ASSIGN="->"
LBB="[["
RBB="]]"
// onthefly FOR
// onthefly IN
// onthefly IF
// onthefly ELSE
// onthefly WHILE
// onthefly NEXT
// onthefly BREAK
// onthefly REPEAT
GT=">"
GE=">="
LT="<"
LE="<="
EQ="=="
NE="!="
AND="&"
OR="|"
AND2="&&"
OR2="||"
NS_GET="::"
NS_GET_INT=":::"
// onthefly COMMENT
// onthefly SPACES
// onthefly ROXYGEN_COMMENT
SYMBOL_FORMALS="..."
// just the = with a function definition, there should be part of a parser rule EQ_FORMALS
// see example parsing ::= the name of a named argument in a function call EQ_SUB
// see example parsing ::= the = of a named argument in a function call SYMBOL_SUB
// SYMBOL_FUNCTION_CALL the name of the function of a function call
// ?? SYMBOL_PACKAGE
// ?? COLON_ASSIGN
SLOT="@"

// additional tokens because of grammar def
SEMICOLON=";"
LEFT_BRACE="{"
RIGHT_BRACE="}"
LEFT_BRACKET="["
RIGHT_BRACKET="]"
LEFT_PAREN="("
RIGHT_PAREN=")"
EOL="EOL"

COLON=":"
COMMA=","
SEMICOLON=";"
DOT="."
TILDE="~"

LIST_SUBSET="$"
//VARARGS="..."
ARITH_PLUS="+"
ARITH_MINUS="-"
NEGATION="!"
QUESTION="?"
ARITH_MULT="*"
ARITH_DIV="/"
ARITH_MOD="%"
ARITH_EXPONENTIAION="^"
//ARITH_MISC

  named="com.r4intellij.psi.RNamedElement"
  namedImpl="com.r4intellij.psi.impl.bnfclasses.RNamedElementImpl"
  parenthesized="com.r4intellij.psi.impl.bnfclasses.RParenthesized"
}


external grammar ::= parseGrammar prog

prog ::=
//END_OF_INPUT //todo match an empty file --> add unit test
    EOL
    |  expr_or_assign? EOL
    |  expr_or_assign ';'
    |  COMMENT


expr_or_assign ::= equal_assign | expr

equal_assign ::= expr EQ_ASSIGN expr_or_assign

expr ::=  ('{' exprlist '}' |
	'(' expr_or_assign ')' |
	'-' expr |
	'+' expr |
	'!' expr |
	'~' expr |
	'?' expr |
	fundef |
	IF ifcond expr_or_assign |
	IF ifcond expr_or_assign ELSE expr_or_assign |
	FOR forcond expr_or_assign |
	WHILE cond expr_or_assign |
	REPEAT expr_or_assign |
	SYMBOL NS_GET SYMBOL |
	SYMBOL NS_GET STR_CONST |
	STR_CONST NS_GET SYMBOL |
	STR_CONST NS_GET STR_CONST |
	SYMBOL NS_GET_INT SYMBOL |
	SYMBOL NS_GET_INT STR_CONST |
	STR_CONST NS_GET_INT SYMBOL |
	STR_CONST NS_GET_INT STR_CONST |
	NUM_CONST |
	STR_CONST |
	NULL_CONST |
	SYMBOL |
	NEXT |
	BREAK) // end of first half
    (( ':' | '+' | '-' | '*' | '/' | '^' | ARITH_MISC | '%' | '~' | '?' | LT | LE | EQ | NE | GE | GT | AND | OR | AND2 | OR2 | LEFT_ASSIGN | RIGHT_ASSIGN ) expr |
	'(' sublist ')' |
	'[[' sublist ']]' |
	'[' sublist ']' |
	'$' SYMBOL |
	'$' STR_CONST |
	'@' SYMBOL |
	'@' STR_CONST
	)* ;

fundef ::= FUNCTION '(' formlist ')' expr_or_assign;

cond ::= '(' expr ')'

ifcond ::= '(' expr ')'

forcond ::= '(' SYMBOL IN expr ')'

// old left recursive exprlist
//exprlist ::= whitespace
//        | expr_or_assign
//        | exprlist ';' expr_or_assign
//        | exprlist ';'
//        | exprlist EOL expr_or_assign
//        | exprlist EOL
exprlist ::=   (expr_or_assign) (';' expr_or_assign | ';' | EOL expr_or_assign | EOL)* ;

sublist ::= sub (EOL ',' sub)*

sub ::= whitespace | expr
   | SYMBOL EQ_ASSIGN
   | SYMBOL EQ_ASSIGN expr
   | STR_CONST EQ_ASSIGN
   | STR_CONST EQ_ASSIGN expr
   | NULL_CONST EQ_ASSIGN
   | NULL_CONST EQ_ASSIGN expr

// left recursive formlist
//formlist ::= empty | SYMBOL
//        | SYMBOL EQ_ASSIGN expr
//        | formlist ',' SYMBOL
//        | formlist ',' SYMBOL EQ_ASSIGN expr
//        | SYMBOL_FORMALS
// todo avoid that the parser accepts several symbol formals
formlist ::=   [ ( SYMBOL '=' expr | SYMBOL | SYMBOL_FORMALS)
                 (',' SYMBOL | ',' SYMBOL '=' expr | SYMBOL_FORMALS)* ];


//cr ::= /* empty */ //todo
